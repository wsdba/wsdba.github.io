<!DOCTYPE html><head><title>我如何将博客首页体积降至 3 KB - kkocdko's blog</title><meta name="description" content="百尺竿头，更进一步"><script src="/bundle.js" onload="[].flat||(location='/update.html')"></script></head><main><article><h1>我如何将博客首页体积降至 3 KB</h1><blockquote><p>这并不是一篇网络上泛滥的“前端体积优化”文章。</p><p>百尺竿头，更进一步！本文以我的博客为例，介绍<strong>极限控制</strong>页面体积的奇技淫巧。</p></blockquote><h2 id="成果预览">成果预览</h2> <img src="/res/20210612-0010-001.webp" width="745" height="305"><p>眼见为实，本博客 <a href="/.">首页</a> 的网络传输总体积为 <code>2.6 KB</code>。</p><h2 id="需求精简">需求精简</h2><p>平淡无奇的页面，体积再小，也不足为奇。我需要：</p><ul><li>单页面（<a href="https://developer.mozilla.org/en-US/docs/Glossary/SPA">SPA</a>）。</li><li>使用 <a href="https://material.io">Material Design</a> 质感设计风格。</li><li>快速构建与加载。</li></ul><p>没有代码是最好的代码。尽量削减需求，才能根本上减小体积。于是——</p><ul><li>仅适配新版浏览器。</li><li>仅使用 Markdown 核心语法。</li><li>部分遵循 Material Design，舍弃复杂特性。</li><li>前端与生成器均不使用框架。</li></ul><h2 id="打包与压缩">打包与压缩</h2><p>资源打包早已是常识，但我希望走得更远一些，<strong>将所有资源（除页面本身外）合并至单个文件</strong>。这不仅能省去请求头体积，还可降低信息熵，使压缩后的总体积更小。</p><p>于是有 <code>bundle.js</code>：</p><pre><code class="language-javascript">let avatar = `/*{avatar}*/`;
document.head.insertAdjacentHTML(&quot;beforeend&quot;, `/*{head}*/`);</code></pre><p>其中形似 <code>/*{xxx}*/</code> 的标记，将被替换为需要嵌入的资源。而嵌入的内容中也可含有标记，不断替换，直至所有资源嵌入完成。</p><p>例如，<code>/*{head}*/</code> 将被替换为 <code>head.html</code>：</p><pre><code class="language-html">&lt;link rel=&quot;icon&quot; href=&quot;${avatar}&quot; /&gt;
&lt;style&gt;
  /*{style}*/
&lt;/style&gt;</code></pre><p>注意到，我在这里将网页图标也嵌入了。但即便你不需要图标，也应指定一个 <code>&lt;link ... href=&quot;data:&quot;&gt;</code> 空白图标，否则浏览器将自动向 <code>/favicon.ico</code> 发送多余请求。</p><p>要嵌入图像，我们通常会将其以 Base64 进行编码。但我使用的是 SVG 图标，为文本格式，因而将特殊字符使用 <code>encodeURIComponent()</code> 转换后，就可直接直接写作 <code>data:image/svg+xml,&lt;svg ... &lt;/svg&gt;</code>，从而避免 Base64 编码所带来的体积膨胀。</p><p>切记，引入 <code>bundle.js</code> 的 <code>&lt;script&gt;</code> 标签不应有 <code>defer</code> 属性，且必须在 <code>&lt;head&gt;</code> 中。这与大多数教程的推荐做法背道而驰，却正是我想要的效果：在嵌入的 CSS 加载完成之前，不要渲染页面。</p><p>由于请求数量少，再佐以 HTTP2 的 <a href="https://developers.google.com/web/fundamentals/performance/http2/#server_push">服务端推送</a>，阻塞渲染并不会明显拖慢加载速度。</p><h2 id="单页面方案">单页面方案</h2><p>在静态页面实现 SPA，通常需分别生成静态页面和 JSON。框架辅佐下开箱即用，但有诸多缺点：</p><ul><li>响应的 JSON 是未转换的 Markdown，解析导致页面卡顿（可改善）。</li><li>首次访问加载时间较长（可使用 SSR 解决）。</li><li>体积大，构建慢（无解）。</li></ul><p>还有一种方法是 <a href="https://github.com/rafgraph/spa-github-pages">以 404 页面为路由</a>。易于实现（利用 GitHub API）但首屏加载缓慢，且极不利于 SEO。</p><p>而我的博客则选择了另一条路——</p><p>得益于前文的资源打包，页面中无效内容极少（只需引入 <code>bundle.js</code> 即可）。例如，某篇文章生成页面如下：</p><pre><code class="language-html">&lt;title&gt;Hello - kkocdko&#39;s blog&lt;/title&gt;
&lt;script src=&quot;/bundle.js&quot;&gt;&lt;/script&gt;
&lt;main&gt;
  &lt;article&gt;
    &lt;h1&gt;Hello&lt;/h1&gt;
    &lt;p&gt;Hello world!&lt;/p&gt;
  &lt;/article&gt;
&lt;/main&gt;</code></pre><p>实现页内切换，首先要标记页内链接。一般思路是使用 <code>data-xxx</code> 自定义属性，但在这里我们约定：<code>&lt;a&gt;</code> 标签 <code>href</code> 属性以 <code>/.</code> 前缀，即为页内链接，如 <code>&lt;a href=&quot;/./hi&quot;&gt;Hi&lt;/a&gt;</code>。众所周知 <code>.</code> 代表当前目录，因而此做法不会造成行为改变。</p><p>这种做法的好处，远不止于抠出几个字节，更重要的是，这允许我们以原生 Markdown 语法在文章内写出页内链接 <code>[关于](/./about)</code> 而不是突兀的 <code>&lt;a data-spa-link href=&quot;/about&gt;关于&lt;/a&gt;</code>。</p><p>链接被点击后，<strong>直接 <code>fetch</code> 目标页面，提取内容，更新到当前页面上</strong>：</p><pre><code class="language-javascript">onpopstate = () =&gt;
  fetch(location) // location.toString() === location.href
    .then((res) =&gt; res.text())
    .then((text) =&gt; {
      // 有些玄学的解构，实现提取内容
      [, document.title, , box.innerHTML] = text.split(/&lt;\/?title&gt;|&lt;\/?main&gt;/);
    });</code></pre><p>赋值给 <code>onpopstate</code> 是为了使得页面在前进、后退时也能更新内容。</p><p>再实现一下监听页内链接（每次页面更新后运行）：</p><pre><code class="language-javascript">for (const element of document.querySelectorAll(&#39;a[href^=&quot;/.&quot;]&#39;))
  element.onclick = function (event) {
    event.preventDefault(); // 避免直接跳转
    history.pushState(null, null, this.href); // 更新 URL
    onpopstate(); // 因为 &quot;pushState&quot; 不会触发 &quot;popstate&quot; 事件
  };</code></pre><p>至此，我们初步实现了单页面支持。</p><h2 id="简洁的实现代码">简洁的实现代码</h2><p>有很多技巧，能够<strong>在实现等价功能的前提下，减少所需的代码量</strong>。当然，在生产项目中使用时需谨慎。</p><p>此处仅举一例。本博客页面中 <code>&lt;main&gt;</code> 是页面主要内容的容器，其对应 CSS 需要实现的功能有：</p><ul><li>在顶部、底部留白。</li><li>一代子元素（卡片）居中，圆角，投影效果，元素间留白。</li><li>宽度过低时（移动端）取消各处空白、阴影；子元素的间隙改为分隔线。</li></ul><p>通常的实现如下，共 452 字符：</p><pre><code class="language-css">main {
  display: grid;
  grid-gap: 20px;
  justify-content: center;
  margin-top: 75px;
  margin-bottom: 25px;
}

main &gt; * {
  width: 680px;
  margin-top: 20px;
  border-radius: 8px;
  box-shadow: 0 1px 4px #aaaaaa;
}

@media screen and (max-width: 750px) {
  main {
    grid-gap: 0;
    margin-top: 50px;
    margin-bottom: 0;
  }

  main &gt; * {
    width: 100%;
    border-bottom: 1px solid #aaa;
    border-radius: unset;
    box-shadow: none;
  }
}</code></pre><p>这里有很多可优化的位点。</p><ul><li><p><code>@media</code> 查询中 <code>screen and</code> 是不必要的，匹配所有类型并没有太大问题。</p></li><li><p>有些属性在 <code>@media (max-width ...</code> 中被重置，可以改 <code>max-width</code> 为 <code>min-width</code>，再将宽度过低 / 宽度正常的属性调换，省去重置语句。</p></li><li><p>Grid 和 <code>justify-content</code> 是不必要的，我们可以对 <code>&lt;main&gt;</code> 固定宽度以约束子元素，再使用 <code>margin: auto</code> 居中。</p></li><li><p>上一条修改过后，<code>margin</code> 可以与顶部留白 <code>margin-top</code> 缩写，原有的 4 行代码，缩减为单行 <code>margin: 75px auto 25px</code>。</p></li><li><p>子元素间隙用 <code>margin-top</code> 实现。首个子元素的 <code>margin-top</code> 与容器的 <code>margin</code> 重叠，顶部空白保持正常。</p></li><li><p>使用 <code>box-shadow</code> 向下偏移 <code>1px</code> 来替代 <code>border-bottom</code>，同时省去 <code>@media</code> 块中的重置语句。</p></li></ul><p>应用上述技巧，实现如下：</p><pre><code class="language-css">main {
  width: 100%;
  min-height: 100vh;
  margin: 50px 0 0;
}

main &gt; * {
  margin-top: 1px;
  box-shadow: 0 1px #ddd;
}

@media (min-width: 750px) {
  main {
    width: 680px;
    margin: 75px auto 25px;
  }

  main &gt; * {
    margin-top: 20px;
    border-radius: 8px;
    box-shadow: 0 1px 4px #aaa;
  }
}</code></pre><p>仅 309 字符，相较原来的 452 字符，减少了 <code>32%</code>，非常可观。</p><h2 id="收">收</h2><p>看得开心么~</p><p>这只是本人博客项目中所用技巧的一小部分。其他内容，限于篇幅，不再穷举。若你想要深入了解，请见 <a href="https://github.com/kkocdko/kblog">kblog - GitHub</a>。</p><h2 id="附">附</h2><ul><li>测试用静态服务器代码（推荐使用 <a href="https://github.com/FiloSottile/mkcert">mkcert</a> 管理证书）：</li></ul><pre><code class="language-javascript">const serve = require(&quot;http2&quot;).createSecureServer;
const read = require(&quot;fs&quot;).readFileSync;
const load = (p) =&gt; require(&quot;zlib&quot;).brotliCompressSync(read(p));
serve({ cert: read(&quot;cert.pem&quot;), key: read(&quot;cert-key.pem&quot;) }, (_, res) =&gt; {
  res.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf8&quot;);
  res.writeHead(200, { &quot;content-encoding&quot;: &quot;br&quot; }).end(load(&quot;index.html&quot;));
  res.createPushResponse({ &quot;:path&quot;: &quot;/bundle.js&quot; }, (_, r) =&gt; {
    r.writeHead(200, { &quot;content-encoding&quot;: &quot;br&quot; }).end(load(&quot;bundle.js&quot;));
  });
}).listen(4000);</code></pre></article></main>